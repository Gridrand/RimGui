"use strict";(self.webpackChunkwebsite_3=self.webpackChunkwebsite_3||[]).push([[4911],{4649:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"widgets/splitter","title":"Splitter","description":"See the SplitterDemo class.","source":"@site/docs/widgets/splitter.md","sourceDirName":"widgets","slug":"/widgets/splitter","permalink":"/rimgui/docs/widgets/splitter","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Spacing","permalink":"/rimgui/docs/widgets/spacing"},"next":{"title":"Sprite","permalink":"/rimgui/docs/widgets/sprite"}}');var n=t(4848),s=t(8453);const a={},o="Splitter",l={},d=[];function c(e){const i={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"splitter",children:"Splitter"})}),"\n",(0,n.jsx)(i.p,{children:"See the SplitterDemo class."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-csharp",children:'// Horizontal sizes and minimum sizes for the split containers\r\nfloat horizontalSize1 = 100f;\r\nfloat horizontalSize2 = 100f;\r\nfloat horizontalMinSize1 = 30f;\r\nfloat horizontalMinSize2 = 10f;\r\n\r\n// Vertical sizes and minimum sizes for the split containers\r\nfloat verticalSize1 = 100f;\r\nfloat verticalSize2 = 100f;\r\nfloat verticalMinSize1 = 20f;\r\nfloat verticalMinSize2 = 20f;\r\n\r\n// Widths for horizontal split containers (for demonstration)\r\nreadonly List<float> widths = new() { 50f, 50f, 50f };\r\nreadonly List<float> tempWidths = new();\r\n\r\n/// <summary>\r\n/// Demonstrates the use of splitters for resizing widgets horizontally.\r\n/// Provides a minimum size input for each side and allows resizing of two widgets horizontally.\r\n/// </summary>\r\nvoid DrawByHorizontal()\r\n{\r\n    Gui.Heading("Axis.Horizontal");\r\n\r\n    // Inputs for the minimum size of the horizontal split areas\r\n    Gui.LabelInputNumeric("MinSize1", ref horizontalMinSize1);\r\n    Gui.LabelInputNumeric("MinSize2", ref horizontalMinSize2);\r\n\r\n    using (Style.SpacingXs.Begin(0f))\r\n    {\r\n        // Allocate space for the two widgets and the splitter between them\r\n        using var rects2 = RectsBuilder\r\n            .FixedNonScale(horizontalSize1)\r\n            // Space for the splitter\r\n            .Fixed(1f)\r\n            .FixedUnscaled(horizontalSize2)\r\n            .BuildAllocatedHorizontal(horizontalSize1 + 1f * ScaleFactor + horizontalSize2, 50f);\r\n\r\n        // Create the splitter that resizes the two widgets horizontally\r\n        var result2 = Gui.Splitter(Axis.Horizontal, rects2.R1, horizontalSize1, horizontalSize2, horizontalMinSize1, horizontalMinSize2);\r\n        horizontalSize1 = result2.size1;\r\n        horizontalSize2 = result2.size2;\r\n\r\n        Gui.Frame(rects2.Whole);\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Demonstrates the use of splitters for resizing widgets vertically.\r\n/// Provides a minimum size input for each side and allows resizing of two widgets vertically.\r\n/// </summary>\r\nvoid DrawByVertical()\r\n{\r\n    Gui.Heading("Axis.Vertical");\r\n\r\n    // Inputs for the minimum size of the vertical split areas\r\n    Gui.LabelInputNumeric("MinSize1", ref verticalMinSize1);\r\n    Gui.LabelInputNumeric("MinSize2", ref verticalMinSize2);\r\n\r\n    // note:Since drawing with SpacingY set to 0 does not add space, explicitly add space.\r\n    Ctx.AddSpaceIfNeeded();\r\n\r\n    using (Style.SpacingYs.Begin(0f))\r\n    {\r\n        // Allocate space for the two widgets and the vertical splitter between them\r\n        using var rects = RectsBuilder\r\n            .FixedNonScale(verticalSize1)\r\n            // Space for the splitter\r\n            .Fixed(1f)\r\n            .FixedUnscaled(verticalSize2)\r\n            .BuildAllocatedVertical(height: verticalSize1 + 1f * ScaleFactor + verticalSize2);\r\n\r\n        // Create the splitter that resizes the two widgets vertically\r\n        var result = Gui.Splitter(Axis.Vertical, rects.R1, verticalSize1, verticalSize2, verticalMinSize1, verticalMinSize2);\r\n        verticalSize1 = result.size1;\r\n        verticalSize2 = result.size2;\r\n\r\n        Gui.Frame(rects.Whole);\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Demonstrates the use of splitters in a list of horizontally aligned elements.\r\n/// Allows dynamic resizing of individual items in a horizontal list using splitters.\r\n/// </summary>\r\nvoid DrawLists()\r\n{\r\n    Gui.Heading("Axis.Horizontal 2");\r\n\r\n    using (Ctx.Horizontal())\r\n    {\r\n        // Temporary list to store modified widths during this frame\r\n        tempWidths.ReplaceAll(widths);\r\n\r\n        // note:The position of the text and splitter is determined using the width from the previous frame.\r\n        //      Using the width modified by operations in the current frame would mean altering a finalized value, which is not allowed.\r\n        for (int i = 0; i < widths.Count; i++)\r\n        {\r\n            using var s = Ctx.PushId(i);\r\n\r\n            // Draw the text for the item with a fixed width\r\n            Gui.NextWidthUnscaled(widths[i]).Text($"{i}");\r\n\r\n            if (i != widths.Count - 1)\r\n            {\r\n                // Space between the items\r\n                Gui.NextWidth(4f).Spacing();\r\n\r\n                var splitterRect = Ctx.GetLastWidgetRect();\r\n                var splitterResult = Gui.Splitter(Axis.Horizontal, splitterRect, tempWidths[i], tempWidths[i + 1], 10f, 10f);\r\n                tempWidths[i] = splitterResult.size1;\r\n                tempWidths[i + 1] = splitterResult.size2;\r\n            }\r\n        }\r\n\r\n        // Apply the modified widths to the original list\r\n        widths.ReplaceAll(tempWidths);\r\n    }\r\n}\n'})})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var r=t(6540);const n={},s=r.createContext(n);function a(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);