"use strict";(self.webpackChunkwebsite_3=self.webpackChunkwebsite_3||[]).push([[1884],{1466:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"widgets/scroll","title":"Scroll","description":"See the ScrollDemo class.","source":"@site/docs/widgets/scroll.md","sourceDirName":"widgets","slug":"/widgets/scroll","permalink":"/rimgui/docs/widgets/scroll","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"ListView","permalink":"/rimgui/docs/widgets/list-view"},"next":{"title":"Separator","permalink":"/rimgui/docs/widgets/separator"}}');var i=n(4848),o=n(8453);const a={},l="Scroll",s={},d=[];function c(e){const r={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"scroll",children:"Scroll"})}),"\n",(0,i.jsx)(r.p,{children:"See the ScrollDemo class."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-csharp",children:'\r\nvoid DrawSettings()\r\n{\r\n    Gui.Heading("Settings");\r\n\r\n    var rects = RectsBuilder.AllocateMainAndToolTipRect();\r\n\r\n    Gui.NextRect(rects.Main).LabelInputBool("FixToBottom", ref shouldFixToBottom);\r\n    Gui.NextRect(rects.ToolTip).ToolTip("Keep the scroll fixed at the bottom even when new widgets are added.");\r\n}\r\n\r\nvoid DrawWithDynamic()\r\n{\r\n    Gui.NextWidth(Ctx.GetCurrentRegionWidth() - CharFixedMap.CalcToolTipXAdvance() - Style.SpacingXs.Get())\r\n        .Heading("Dynamic");\r\n\r\n    Gui.NextRect(Ctx.GetHorizontalRemainRect())\r\n        .ToolTip(\r\n        "A scroll that allows dynamic addition of widgets.\\n" +\r\n        "Suitable when the number of widgets is not large, as it processes all of them.");\r\n\r\n    // Controls for modifying scroll properties.\r\n    Gui.LabelSlider("OuterTextCount", ref outerTextCount, 0, 100);\r\n    Gui.LabelSlider("innerTextCount", ref innerTextCount, 0, 100);\r\n    Gui.LabelSlider("OuterHeight", ref outerHeight, 0, 300);\r\n    Gui.LabelSlider("InnerHeight", ref innerHeight, 0, 300);\r\n\r\n    using var p = Gui.BeginFramePadding1();\r\n    Gui.NextHeight(Size.Fixed(outerHeight));\r\n    // Outer scrollable area.\r\n    if (Gui.BeginScroll())\r\n    {\r\n        using (Gui.BeginFramePadding1())\r\n        {\r\n            // Inner scrollable area.\r\n            Gui.NextHeight(Size.Fixed(innerHeight));\r\n            if (Gui.BeginScroll())\r\n            {\r\n                for (int i = 0; i < innerTextCount; i++)\r\n                {\r\n                    using (Ctx.PushId(i))\r\n                        Gui.Text($"inner:{i}");\r\n                }\r\n                Gui.EndScroll();\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < outerTextCount; i++)\r\n        {\r\n            Gui.Text($"outer:{i}");\r\n        }\r\n\r\n        Gui.EndScroll();\r\n    }\r\n}\r\n\r\nvoid DrawUsingHandler()\r\n{\r\n    Gui.NextWidth(Ctx.GetCurrentRegionWidth() - CharFixedMap.CalcToolTipXAdvance() - Style.SpacingXs.Get())\r\n        .Heading("Fixed");\r\n    Gui.NextRect(Ctx.GetHorizontalRemainRect())\r\n        .ToolTip(\r\n        "A scroll where the number and height of widgets must be determined before processing.\\n" +\r\n        "It only processes the displayed widgets, making it fast even when there are many.");\r\n\r\n    // Controls for modifying fixed scroll properties.\r\n    Gui.LabelInputNumeric("Height", ref height);\r\n    Gui.LabelSlider("TextCount", ref textCountWithIterator, 0, 100);\r\n\r\n    using var p = Gui.BeginFramePadding1();\r\n    // Create a scroll handler with fixed height and item count.\r\n    var handler = Gui.CreateScrollHandler(height, textCountWithIterator, Style.StandardHeight);\r\n    // Render only visible items based on the scroll handler.\r\n    while (handler.Next())\r\n    {\r\n        Gui.Text($"{handler.CurrentIndex}");\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Demonstrates a scroll handler that automatically extends to the bottom of the window.\r\n/// </summary>\r\nvoid DrawToBottomOfWindow()\r\n{\r\n    Gui.Heading("To the bottom of the window");\r\n    using var p = Gui.BeginFramePadding1();\r\n\r\n    Ctx.AddSpaceIfNeeded();\r\n    // Create a scroll handler that fills the remaining height in the window.\r\n    var handler = Gui.CreateScrollHandler(Ctx.GetRemainRect().height, 100, Style.StandardHeight);\r\n    // Render only visible items based on the scroll handler.\r\n    while (handler.Next())\r\n    {\r\n        Gui.Text(handler.CurrentIndex.ToString());\r\n    }\r\n}\n'})})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>l});var t=n(6540);const i={},o=t.createContext(i);function a(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:r},e.children)}}}]);